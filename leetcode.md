# Leetcode Problems


|ID|NOTES|LINK CPP|LINK Python|URL|
|--|-----|----|---|---|
|**EASY**|**EASY**|**EASY**|**EASY**|**EASY**|
|1|Map for tracking the value and the index, go through all the values and stop as soon as we find a number that fits.|[Code CPP](problems/leetcode/1.cpp)|[Code Python](problems/leetcode/1.py)|[LC_URL](https://leetcode.com/problems/two-sum)|
|20|Create a stack and push open brackets onto that stack. In case the current char is a closed bracket, check if the top of the stack is a complementary bracket.|[Code CPP](problems/leetcode/20.cpp)|[Code Python](problems/leetcode/20.py)|[LC_URL](https://leetcode.com/problems/valid-parentheses)|
|21|Create dummy node in beginning. For each node take the one with smaller value and append it to the list, then move the current pointer forward. Repeat until both lists have been iterated.|[Code CPP](problems/leetcode/21.cpp)|[Code Python](problems/leetcode/21.py)|[LC_URL](https://leetcode.com/problems/merge-two-sorted-lists)|
|35|Simple binary search to until the value is found, if not return left pointer index.|[Code CPP](problems/leetcode/35.cpp)|[Code Python](problems/leetcode/35.py)|[LC_URL](https://leetcode.com/problems/search-insert-position/)|
|69|Binary search from 1 to x, check if x//mid value is mid -> therefore we found the number for the sqrt.|[Code CPP](problems/leetcode/69.cpp)|[Code Python](problems/leetcode/69.py)|[LC_URL](https://leetcode.com/problems/sqrtx/description/)|
|94|DFS left node, add root val, dfs right node.|[Code CPP](problems/leetcode/94.cpp)|[Code Python](problems/leetcode/94.py)|[LC_URL](https://leetcode.com/problems/binary-tree-inorder-traversal/)|
|100|Recursively check left and right subtree and compare.|[Code CPP](problems/leetcode/100.cpp)|[Code Python](problems/leetcode/100.py)|[LC_URL](https://leetcode.com/problems/same-tree)|
|101|Always compare left and right, recursively.|[Code CPP](problems/leetcode/101.cpp)|[Code Python](problems/leetcode/101.py)|[LC_URL](https://leetcode.com/problems/symmetric-tree/)|
|104|Return the recursive maximum of left subtree and right subtree, adding 1 each time we find a node.|[Code CPP](problems/leetcode/104.cpp)|[Code Python](problems/leetcode/104.py)|[LC_URL](https://leetcode.com/problems/maximum-depth-of-binary-tree)|
|110|DFS on each node, check if the nodes below are balanced and return the depth as well.|[Code CPP](problems/leetcode/110.cpp)|[Code Python](problems/leetcode/110.py)|[LC_URL](https://leetcode.com/problems/balanced-binary-tree)|
|111|Search through the graph, always checking if currently at a leafnode. If yes, check the depth and set the global min depth.|[Code CPP](problems/leetcode/111.cpp)|[Code Python](problems/leetcode/111.py)|[LC_URL](https://leetcode.com/problems/minimum-depth-of-binary-tree/)|
|112|Go through the graph, if reaching leafnode check the current sum, if it matches return true.|[Code CPP](problems/leetcode/112.cpp)|[Code Python](problems/leetcode/112.py)|[LC_URL](https://leetcode.com/problems/path-sum/)|
|121|Go through all prices and always save the lowest, max = difference from lowest - current.|[Code CPP](problems/leetcode/121.cpp)|[Code Python](problems/leetcode/121.py)|[LC_URL](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)|
|125|Two pointers, if not alpha numerical skip char, if alpha numerical compare left and right char. Go through whole string.|[Code CPP](problems/leetcode/125.cpp)|[Code Python](problems/leetcode/125.py)|[LC_URL](https://leetcode.com/problems/valid-palindrome)|
|141|Two pointers, one fast (taking next to next node) one slow (taking next node). If they ever meet, then we know its a circle in the list.|[Code CPP](problems/leetcode/141.cpp)|[Code Python](problems/leetcode/141.py)|[LC_URL](https://leetcode.com/problems/linked-list-cycle)|
|144|Preorder traverse the graph and return the result.|[Code CPP](problems/leetcode/144.cpp)|[Code Python](problems/leetcode/144.py)|[LC_URL](https://leetcode.com/problems/binary-tree-preorder-traversal/)|
|145|Postorder traverse the graph and return the result.|[Code CPP](problems/leetcode/145.cpp)|[Code Python](problems/leetcode/145.py)|[LC_URL](https://leetcode.com/problems/binary-tree-postorder-traversal/)|
|206|Have a current node to store temp states, then shift around the node pointers.|[Code CPP](problems/leetcode/206.cpp)|[Code Python](problems/leetcode/206.py)|[LC_URL](https://leetcode.com/problems/reverse-linked-list)|
|217|Set for keeping seen numbers, if we find number in the set, we return.|[Code CPP](problems/leetcode/217.cpp)|[Code Python](problems/leetcode/217.py)|[LC_URL](https://leetcode.com/problems/contains-duplicate)|
|226|Recursively switch left and right subtree of the current node.|[Code CPP](problems/leetcode/226.cpp)|[Code Python](problems/leetcode/226.py)|[LC_URL](https://leetcode.com/problems/invert-binary-tree)|
|242|One array of 26 chars, for the first char add one for each existing char, for the second string substract one. Check if all values are 0 in the end. Sorting is also an option, by just sorting both and comparing if they are equal.|[Code CPP](problems/leetcode/242.cpp)|[Code Python](problems/leetcode/242.py)|[LC_URL](https://leetcode.com/problems/valid-anagram)|
|257|DFS through the tree, if one leaf node, add the temp nodes of this path to the result.|[Code CPP](problems/leetcode/257.cpp)|[Code Python](problems/leetcode/257.py)|[LC_URL](https://leetcode.com/problems/binary-tree-paths/)|
|543|Count the edges from below to up, always take the max of right+left subtree.|[Code CPP](problems/leetcode/543.cpp)|[Code Python](problems/leetcode/543.py)|[LC_URL](https://leetcode.com/problems/diameter-of-binary-tree)|
|572|Recursively check left and right subtree and compare (See LC 100). Do that for each subtree.|[Code CPP](problems/leetcode/572.cpp)|[Code Python](problems/leetcode/572.py)|[LC_URL](https://leetcode.com/problems/subtree-of-another-tree)|
|704|Simple binary search implementation.|[Code CPP](problems/leetcode/704.cpp)|[Code Python](problems/leetcode/704.py)|[LC_URL](https://leetcode.com/problems/binary-search)|
|**MEDIUM**|**MEDIUM**|**MEDIUM**|**MEDIUM**|**MEDIUM**|
|2|Use carry to check overflow over 10. Go through lists and add numbers, create new list for the result.|[Code CPP](problems/leetcode/2.cpp)|[Code Python](problems/leetcode/2.py)|[LC_URL](https://leetcode.com/problems/add-two-numbers)|
|3|Use set for seen values, go through list with left and right pointer and remove from left until not equal chars. Keep count of maximum value.|[Code CPP](problems/leetcode/3.cpp)|[Code Python](problems/leetcode/3.py)|[LC_URL](https://leetcode.com/problems/longest-substring-without-repeating-characters)|
|5|For each index check to right and left until palidrome is broken, then check if its the longest seen so far.|[Code CPP](problems/leetcode/5.cpp)|[Code Python](problems/leetcode/5.py)|[LC_URL](https://leetcode.com/problems/longest-palindromic-substring/)|
|11|Two pointers, go from outside to the middle and always calculate the max water, move away from the smaller 'pillar'.|[Code CPP](problems/leetcode/11.cpp)|[Code Python](problems/leetcode/11.py)|[LC_URL](https://leetcode.com/problems/container-with-most-water)|
|15|Three pointers, for each number do a two pointer method and calculate the total. if the total is found, add it to a list and return that list in the end.|[Code CPP](problems/leetcode/15.cpp)|[Code Python](problems/leetcode/15.py)|[LC_URL](https://leetcode.com/problems/3sum)|
|16|Sort the input (to make it n^2 and not n^3), then loop through the nums and use two pointers and update the result if the absolute difference is smaller.|[Code CPP](problems/leetcode/16.cpp)|[Code Python](problems/leetcode/16.py)|[LC_URL](https://leetcode.com/problems/3sum-closest/)|
|19|Fast and slow pointer, move the fast pointer N steps in the list. Now move fast and slow pointer equally one step at a time, as long as fast poiner has a valid value.|[Code CPP](problems/leetcode/19.cpp)|[Code Python](problems/leetcode/19.py)|[LC_URL](https://leetcode.com/problems/remove-nth-node-from-end-of-list)|
|22|Use backtracking to add closed and open brackets, for each iteration add a closed and open bracked while counting the amounts of it. Once the length is n like the input, add it to the list of results.|[Code CPP](problems/leetcode/22.cpp)|[Code Python](problems/leetcode/22.py)|[LC_URL](https://leetcode.com/problems/generate-parentheses)|
|31|Search for pivot from right side, when found we know where to switch digits. If no pivot found -> already max number so we return the reverse of it. Else, we swap the digits and in the end reverse the digits to the right of the pivot.|[Code CPP](problems/leetcode/31.cpp)|[Code Python](problems/leetcode/31.py)|[LC_URL](https://leetcode.com/problems/next-permutation/)|
|33|Binary search initially, then check for each step if there is a smaller number to the left. Depending on that, check if there are still smaller numbers to the left, or the target is bigger than the current number. Adjust the pointers accordingly.|[Code CPP](problems/leetcode/33.cpp)|[Code Python](problems/leetcode/33.py)|[LC_URL](https://leetcode.com/problems/search-in-rotated-sorted-array)|
|34|Binary search but have a boolean if we want to search more to left or right once we found the actual value, as there could be more values of the target to the left/right.|[Code CPP](problems/leetcode/34.cpp)|[Code Python](problems/leetcode/34.py)|[LC_URL](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)|
|36|Implementation only, keep track of all boxes, rows and colums in separate data structures and iterate through the input.|[Code CPP](problems/leetcode/36.cpp)|[Code Python](problems/leetcode/36.py)|[LC_URL](https://leetcode.com/problems/valid-sudoku)|
|49|Use array of 26 chars as key for a dictionary, save all anagrams strings in there. Output that anagrams in the end.|[Code CPP](problems/leetcode/49.cpp)|[Code Python](problems/leetcode/49.py)|[LC_URL](https://leetcode.com/problems/group-anagrams)|
|53|Every step, calculate if the sum increases or decreses with the value added, keep track of the max sum.|[Code CPP](problems/leetcode/53.cpp)|[Code Python](problems/leetcode/53.py)|[LC_URL](https://leetcode.com/problems/maximum-subarray)|
|61|One pointer to the end of the list, get the length of the list as well. As k can be higher than the len of the list, calculate k%len(list). Create a circle of the linked list and then cut it at the current position.|[Code CPP](problems/leetcode/61.cpp)|[Code Python](problems/leetcode/61.py)|[LC_URL](https://leetcode.com/problems/rotate-list/)|
|74|Two separate binary searches, first for the row, then for the column. Optimization could be to see the matrix as a long one line array.|[Code CPP](problems/leetcode/74.cpp)|[Code Python](problems/leetcode/74.py)|[LC_URL](https://leetcode.com/problems/search-a-2d-matrix)|
|75|Have three pointers, one for each color (same as left mid right) Always switch the numbers so that the correct colors are at the correct position.|[Code CPP](problems/leetcode/75.cpp)|[Code Python](problems/leetcode/75.py)|[LC_URL](https://leetcode.com/problems/sort-colors/)|
|78|DFS through all possibilities and save it in a global result list.|[Code CPP](problems/leetcode/78.cpp)|[Code Python](problems/leetcode/78.py)|[LC_URL](https://leetcode.com/problems/subsets)|
|79|DFS through for all positions of the board and keep track of seen nodes.|[Code CPP](problems/leetcode/79.cpp)|[Code Python](problems/leetcode/79.py)|[LC_URL](https://leetcode.com/problems/word-search/)|
|80|Two pointer, always check if there is three in a row, if yes set left pointer to the value.|[Code CPP](problems/leetcode/80.cpp)|[Code Python](problems/leetcode/80.py)|[LC_URL](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)|
|81|Binary search but evey time we did not find the target we have to check if we have to go right or left in that case.|[Code CPP](problems/leetcode/81.cpp)|[Code Python](problems/leetcode/81.py)|[LC_URL](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)|
|82|Three pointer solution, keep one on the initial head, one for previous and one for current. Shift current until its uneqal to the one before, then set the previous.next to the current, therefore cutting out the duplicates.|[Code CPP](problems/leetcode/82.cpp)|[Code Python](problems/leetcode/82.py)|[LC_URL](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)|
|86|Two pointers with two helper Nodes/Lists. Go through list and append cur node to the correct list. Combine lists in the end and return the first Node.|[Code CPP](problems/leetcode/86.cpp)|[Code Python](problems/leetcode/86.py)|[LC_URL](https://leetcode.com/problems/partition-list/)|
|98|For each subtree, check the root, left and right to make sure the expectations are met. As per inheritance, if the lower values are greater/smaller we know upwards it will also match.|[Code CPP](problems/leetcode/98.cpp)|[Code Python](problems/leetcode/98.py)|[LC_URL](https://leetcode.com/problems/validate-binary-search-tree)|
|99|Always check for the lowernode, the right and left node. We have to check if the values dont match, and if so if after changing check again to make sure we did not create an additional error.|[Code CPP](problems/leetcode/99.cpp)|[Code Python](problems/leetcode/99.py)|[LC_URL](https://leetcode.com/problems/recover-binary-search-tree/)|
|103|BFS on the graph, have one flag for alternating the left and right direction.|[Code CPP](problems/leetcode/103.cpp)|[Code Python](problems/leetcode/103.py)|[LC_URL](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)|
|107|BFS the nodes, use a deque as result and push the result for the level to the front of the deque.|[Code CPP](problems/leetcode/107.cpp)|[Code Python](problems/leetcode/107.py)|[LC_URL](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)|
|113|Search through the nodes. If on leafnode check the cursum, if matching add curpath to the result.|[Code CPP](problems/leetcode/113.cpp)|[Code Python](problems/leetcode/113.py)|[LC_URL](https://leetcode.com/problems/path-sum-ii/)|
|114|Preorder traverse the graph inversely, first make the right side into a linked list by remembering the previously visited node, then the left tree then the root.|[Code CPP](problems/leetcode/114.cpp)|[Code Python](problems/leetcode/114.py)|[LC_URL](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)|
|116|BFS while setting the next pointer after poping the curnode value.|[Code CPP](problems/leetcode/116.cpp)|[Code Python](problems/leetcode/116.py)|[LC_URL](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)|
|128|Create a set for the numbers, then iterate through the set and for each number we check, if the next, and the next to next and so on number is in the set, only if the previous number is not in the set though. We keep count of the max sequence.|[Code CPP](problems/leetcode/128.cpp)|[Code Python](problems/leetcode/128.py)|[LC_URL](https://leetcode.com/problems/longest-consecutive-sequence)|
|129|DFS through the tree and add the digit to the string of numbers, if on leave node we add the current full number to the total sum.|[Code CPP](problems/leetcode/129.cpp)|[Code Python](problems/leetcode/129.py)|[LC_URL](https://leetcode.com/problems/sum-root-to-leaf-numbers/)|
|130|DFS all the borders, if we find a 'O' we further DFS around it to find the safe spots. In the end, go through the board and mark unsafe 'O's as X.|[Code CPP](problems/leetcode/130.cpp)|[Code Python](problems/leetcode/130.py)|[LC_URL](https://leetcode.com/problems/surrounded-regions/)|
|143|Three steps: 1. Find the middle using slow and fast pointer. 2. Reverse the second part of the list. 3. Merge the lists.|[Code CPP](problems/leetcode/143.cpp)|[Code Python](problems/leetcode/143.py)|[LC_URL](https://leetcode.com/problems/reorder-list)|
|146|Use an ordered dict and keep track on the capacity of the cache when adding an item.|[Code CPP](problems/leetcode/146.cpp)|[Code Python](problems/leetcode/146.py)|[LC_URL](https://leetcode.com/problems/lru-cache)|
|150|Use stack for numbers, if we find a operator we handle the last two numbers on the stack and later push the result again to the stack.|[Code CPP](problems/leetcode/150.cpp)|[Code Python](problems/leetcode/150.py)|[LC_URL](https://leetcode.com/problems/evaluate-reverse-polish-notation)|
|153|Binary search, always compare the current value with the most left or right value to see in which portion of the array we are, change the pointers accordingly to find the lowest value.|[Code CPP](problems/leetcode/153.cpp)|[Code Python](problems/leetcode/153.py)|[LC_URL](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array)|
|155|Two stacks, one for the actual stack and one for the minimum value. Each entry check if we have to push to the minstack.|[Code CPP](problems/leetcode/155.cpp)|[Code Python](problems/leetcode/155.py)|[LC_URL](https://leetcode.com/problems/min-stack)|
|162|Binary search but only check the mid and mid+1.|[Code CPP](problems/leetcode/162.cpp)|[Code Python](problems/leetcode/162.py)|[LC_URL](https://leetcode.com/problems/find-peak-element/description/)|
|167|Two pointers, works as its sorted, and decrease right pointer if number is too big, increase left pointer if too small. If goal is found return left and right pointer values.|[Code CPP](problems/leetcode/167.cpp)|[Code Python](problems/leetcode/167.py)|[LC_URL](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)|
|207|Create one map for all the courses and prerequisites. Iterate through the couse numbers, DFS through all prerequisites. As soon as cycle is detected, return False.|[Code CPP](problems/leetcode/207.cpp)|[Code Python](problems/leetcode/207.py)|[LC_URL](https://leetcode.com/problems/course-schedule/)|
|210|Similar to 207, but at the end of a dfs we have to add the course to the result list.|[Code CPP](problems/leetcode/210.cpp)|[Code Python](problems/leetcode/210.py)|[LC_URL](https://leetcode.com/problems/course-schedule-ii/)|
|211|Use a node structure, having children and marking the end of a word. For input, use addword, add each char to the main root node, going down for the children. For search, use DFS, returning the endstate in case the len of the input is same as len of the word. For '.' just skip one letter in the words, as in search the children of children.|[Code CPP](problems/leetcode/211.cpp)|[Code Python](problems/leetcode/211.py)|[LC_URL](https://leetcode.com/problems/design-add-and-search-words-data-structure/)|
|230|Use a stack, first go down left lane and then check if already k or more elements are in the list, if no then go slowly right side down until more than k elements.|[Code CPP](problems/leetcode/230.cpp)|[Code Python](problems/leetcode/230.py)|[LC_URL](https://leetcode.com/problems/kth-smallest-element-in-a-bst)|
|235|Check for each node if p and q are both smaller/bigger. If one is the case go that direction of the tree, else return the current node.|[Code CPP](problems/leetcode/235.cpp)|[Code Python](problems/leetcode/235.py)|[LC_URL](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree)|
|236|Check for each node if it is p or q. If its true, return the parent node. If left and right are not q and p, return q or p.|[Code CPP](problems/leetcode/236.cpp)|[Code Python](problems/leetcode/236.py)|[LC_URL](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)|
|238|Iterate through the list from both sides, keeping count from beginning and ending. Create new vector/array with these values.|[Code CPP](problems/leetcode/238.cpp)|[Code Python](problems/leetcode/238.py)|[LC_URL](https://leetcode.com/problems/product-of-array-except-self)|
|240|Binary search from top right to bottom left.|[Code CPP](problems/leetcode/240.cpp)|[Code Python](problems/leetcode/240.py)|[LC_URL](https://leetcode.com/problems/search-a-2d-matrix-ii/description/)|
|287|See the array as a linked list and the value of numbers act as a pointer to the index of the array. The duplicate number will always create a cycle, so we have to check if a cycle exists.|[Code CPP](problems/leetcode/287.cpp)|[Code Python](problems/leetcode/287.py)|[LC_URL](https://leetcode.com/problems/find-the-duplicate-number)|
|347|Prio Queue with pair of {number, count}. Build the heap and keep K elements in it. In the end iterate through the heap and output the resulting numbers.|[Code CPP](problems/leetcode/347.cpp)|[Code Python](problems/leetcode/347.py)|[LC_URL](https://leetcode.com/problems/top-k-frequent-elements)|
|424|Sliding window(l,r pointer), try for each window if replacement amount < max replacement allowed, update the result with longest.|[Code CPP](problems/leetcode/424.cpp)|[Code Python](problems/leetcode/424.py)|[LC_URL](https://leetcode.com/problems/longest-repeating-character-replacement/)|
|567|Sliding Window, use Map for tracking the counts. Slide Window over s2 and reduce counts if we find a matching value. In the end, if the count of the not matched s1 values is 0 we know we found the anagram.|[Code CPP](problems/leetcode/567.cpp)|[Code Python](problems/leetcode/567.py)|[LC_URL](https://leetcode.com/problems/permutation-in-string/)|
|739|Iterate the input from the back, use a stack to keep the indices of the temperatures that have a smaller value. Every iteration we iterate and count the number of temperatures lower than the current, so we find out how long until finding a bigger one. Output the result array in the end.|[Code CPP](problems/leetcode/739.cpp)|[Code Python](problems/leetcode/739.py)|[LC_URL](https://leetcode.com/problems/daily-temperatures)|
|797|DFS for the nodes and safe all the paths continuously.|[Code CPP](problems/leetcode/797.cpp)|[Code Python](problems/leetcode/797.py)|[LC_URL](https://leetcode.com/problems/all-paths-from-source-to-target/)|
|853|Sort the cars on the strarting point, use stack to keep track of most recent rounds to finish. If the current car would catch up to the car on the stack, as in the rounds are greater than the rounds on the stack, don't create a new fleet, otherwise create a new fleet. Return the number of fleets in the end.|[Code CPP](problems/leetcode/853.cpp)|[Code Python](problems/leetcode/853.py)|[LC_URL](https://leetcode.com/problems/car-fleet/)|
|875|Treat the eating speed per hour as a list with upper bound (the max pile value) and lower bound. Binary search through this while calulating the total time needed to eat all bananas for each value.|[Code CPP](problems/leetcode/875.cpp)|[Code Python](problems/leetcode/875.py)|[LC_URL](https://leetcode.com/problems/koko-eating-bananas)|
|981|Set -> use a list of value,timestamp for each of the keys. Get -> binary search over the timestamp values.|[Code CPP](problems/leetcode/981.cpp)|[Code Python](problems/leetcode/981.py)|[LC_URL](https://leetcode.com/problems/time-based-key-value-store)|
|1448|For each node calculate the current greatest above value, then dfs down left and right side and return amount of good nodes up.|[Code CPP](problems/leetcode/1448.cpp)|[Code Python](problems/leetcode/1448.py)|[LC_URL](https://leetcode.com/problems/count-good-nodes-in-binary-tree)|
|**HARD**|**HARD**|**HARD**|**HARD**|**HARD**|
|4|Get middle of both arrays, then binary search the smaller one with left/mid/right, and compare with the middle of the long array. Shift left/right/middle accordingly until we have the right points in the long and short array that are the actual middle of the combined array.|[Code CPP](problems/leetcode/4.cpp)|[Code Python](problems/leetcode/4.py)|[LC_URL](https://leetcode.com/problems/median-of-two-sorted-arrays)|
|42|Left and right pointer as well as a maximum value of left and right, the for each step of the way we calculate the water trapped in that step. Return the volume of the water in the end.|[Code CPP](problems/leetcode/42.cpp)|[Code Python](problems/leetcode/42.py)|[LC_URL](https://leetcode.com/problems/trapping-rain-water)|
|76|Map for the letters we have to find. Two pointers to check for each index until all the needed chars are found. In the end, check the lowest length. Output that number.|[Code CPP](problems/leetcode/76.cpp)|[Code Python](problems/leetcode/76.py)|[LC_URL](https://leetcode.com/problems/minimum-window-substring)|
|84|Go through heights and use a stack to keep the latest indexes and heights. As long as current height is smaller than latest stack height, pop from stack and calculate max area. Remember to clear stack in the end by calculating the max area for remaining heights. Return max area.|[Code CPP](problems/leetcode/84.cpp)|[Code Python](problems/leetcode/84.py)|[LC_URL](https://leetcode.com/problems/largest-rectangle-in-histogram)|
|239|Use a vector for the result, deque for the checking. For each step, remove the numbers that are smaller than the current one. Remove also the number that is i-k so that we remove the one that is not in the window. Output the result of the highest numbers, the front of the deque, for each window.|[Code CPP](problems/leetcode/239.cpp)|[Code Python](problems/leetcode/239.py)|[LC_URL](https://leetcode.com/problems/sliding-window-maximum)|
|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|
|X|Explanation.|[Code CPP](problems/leetcode/XA.cpp)|[Code Python](problems/leetcode/XA.py)|[LC_URL](URL)|