# Leetcode Problems


|ID|NOTES|LINK CPP|LINK Python|URL|
|--|-----|----|---|---|
|**EASY**|**EASY**|**EASY**|**EASY**|**EASY**|
|1|Map for tracking the value and the index, go through all the values and stop as soon as we find a number that fits.|[Code CPP](problems/leetcode/1.cpp)|[Code Python](problems/leetcode/1.py)|[LC_URL](https://leetcode.com/problems/two-sum)|
|20|Create a stack and push open brackets onto that stack. In case the current char is a closed bracket, check if the top of the stack is a complementary bracket.|[Code CPP](problems/leetcode/20.cpp)|[Code Python](problems/leetcode/20.py)|[LC_URL](https://leetcode.com/problems/valid-parentheses)|
|21|Create dummy node in beginning. For each node take the one with smaller value and append it to the list, then move the current pointer forward. Repeat until both lists have been iterated.|[Code CPP](problems/leetcode/21.cpp)|[Code Python](problems/leetcode/21.py)|[LC_URL](https://leetcode.com/problems/merge-two-sorted-lists)|
|100|Recursively check left and right subtree and compare.|[Code CPP](problems/leetcode/100.cpp)|[Code Python](problems/leetcode/100.py)|[LC_URL](https://leetcode.com/problems/same-tree)|
|104|Return the recursive maximum of left subtree and right subtree, adding 1 each time we find a node.|[Code CPP](problems/leetcode/104.cpp)|[Code Python](problems/leetcode/104.py)|[LC_URL](https://leetcode.com/problems/maximum-depth-of-binary-tree)|
|110|DFS on each node, check if the nodes below are balanced and return the depth as well.|[Code CPP](problems/leetcode/110.cpp)|[Code Python](problems/leetcode/110.py)|[LC_URL](https://leetcode.com/problems/balanced-binary-tree)|
|121|Go through all prices and always save the lowest, max = difference from lowest - current.|[Code CPP](problems/leetcode/121.cpp)|[Code Python](problems/leetcode/121.py)|[LC_URL](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)|
|125|Two pointers, if not alpha numerical skip char, if alpha numerical compare left and right char. Go through whole string.|[Code CPP](problems/leetcode/125.cpp)|[Code Python](problems/leetcode/125.py)|[LC_URL](https://leetcode.com/problems/valid-palindrome)|
|141|Two pointers, one fast (taking next to next node) one slow (taking next node). If they ever meet, then we know its a circle in the list.|[Code CPP](problems/leetcode/141.cpp)|[Code Python](problems/leetcode/141.py)|[LC_URL](https://leetcode.com/problems/linked-list-cycle)|
|206|Have a current node to store temp states, then shift around the node pointers.|[Code CPP](problems/leetcode/206.cpp)|[Code Python](problems/leetcode/206.py)|[LC_URL](https://leetcode.com/problems/reverse-linked-list)|
|217|Set for keeping seen numbers, if we find number in the set, we return.|[Code CPP](problems/leetcode/217.cpp)|[Code Python](problems/leetcode/217.py)|[LC_URL](https://leetcode.com/problems/contains-duplicate)|
|226|Recursively switch left and right subtree of the current node.|[Code CPP](problems/leetcode/226.cpp)|[Code Python](problems/leetcode/226.py)|[LC_URL](https://leetcode.com/problems/invert-binary-tree)|
|242|One array of 26 chars, for the first char add one for each existing char, for the second string substract one. Check if all values are 0 in the end. Sorting is also an option, by just sorting both and comparing if they are equal.|[Code CPP](problems/leetcode/242.cpp)|[Code Python](problems/leetcode/242.py)|[LC_URL](https://leetcode.com/problems/valid-anagram)|
|543|Count the edges from below to up, always take the max of right+left subtree.|[Code CPP](problems/leetcode/543.cpp)|[Code Python](problems/leetcode/543.py)|[LC_URL](https://leetcode.com/problems/diameter-of-binary-tree)|
|572|Recursively check left and right subtree and compare (See LC 100). Do that for each subtree.|[Code CPP](problems/leetcode/572.cpp)|[Code Python](problems/leetcode/572.py)|[LC_URL](https://leetcode.com/problems/subtree-of-another-tree)|
|704|Simple binary search implementation.|[Code CPP](problems/leetcode/704.cpp)|[Code Python](problems/leetcode/704.py)|[LC_URL](https://leetcode.com/problems/binary-search)|
|**MEDIUM**|**MEDIUM**|**MEDIUM**|**MEDIUM**|**MEDIUM**|
|2|Use carry to check overflow over 10. Go through lists and add numbers, create new list for the result.|[Code CPP](problems/leetcode/2.cpp)|[Code Python](problems/leetcode/2.py)|[LC_URL](https://leetcode.com/problems/add-two-numbers)|
|3|Use set for seen values, go through list with left and right pointer and remove from left until not equal chars. Keep count of maximum value.|[Code CPP](problems/leetcode/3.cpp)|[Code Python](problems/leetcode/3.py)|[LC_URL](https://leetcode.com/problems/longest-substring-without-repeating-characters)|
|11|Two pointers, go from outside to the middle and always calculate the max water, move away from the smaller 'pillar'.|[Code CPP](problems/leetcode/11.cpp)|[Code Python](problems/leetcode/11.py)|[LC_URL](https://leetcode.com/problems/container-with-most-water)|
|15|Three pointers, for each number do a two pointer method and calculate the total. if the total is found, add it to a list and return that list in the end.|[Code CPP](problems/leetcode/15.cpp)|[Code Python](problems/leetcode/15.py)|[LC_URL](https://leetcode.com/problems/3sum)|
|19|Fast and slow pointer, move the fast pointer N steps in the list. Now move fast and slow pointer equally one step at a time, as long as fast poiner has a valid value.|[Code CPP](problems/leetcode/19.cpp)|[Code Python](problems/leetcode/19.py)|[LC_URL](https://leetcode.com/problems/remove-nth-node-from-end-of-list)|
|22|Use backtracking to add closed and open brackets, for each iteration add a closed and open bracked while counting the amounts of it. Once the length is n like the input, add it to the list of results.|[Code CPP](problems/leetcode/22.cpp)|[Code Python](problems/leetcode/22.py)|[LC_URL](https://leetcode.com/problems/generate-parentheses)|
|33|Binary search initially, then check for each step if there is a smaller number to the left. Depending on that, check if there are still smaller numbers to the left, or the target is bigger than the current number. Adjust the pointers accordingly.|[Code CPP](problems/leetcode/33.cpp)|[Code Python](problems/leetcode/33.py)|[LC_URL](https://leetcode.com/problems/search-in-rotated-sorted-array)|
|36|Implementation only, keep track of all boxes, rows and colums in separate data structures and iterate through the input.|[Code CPP](problems/leetcode/36.cpp)|[Code Python](problems/leetcode/36.py)|[LC_URL](https://leetcode.com/problems/group-anagrams)|
|49|Use array of 26 chars as key for a dictionary, save all anagrams strings in there. Output that anagrams in the end.|[Code CPP](problems/leetcode/49.cpp)|[Code Python](problems/leetcode/49.py)|[LC_URL](https://leetcode.com/problems/group-anagrams)|
|74|Two separate binary searches, first for the row, then for the column. Optimization could be to see the matrix as a long one line array.|[Code CPP](problems/leetcode/74.cpp)|[Code Python](problems/leetcode/74.py)|[LC_URL](https://leetcode.com/problems/search-a-2d-matrix)|
|98|For each subtree, check the root, left and right to make sure the expectations are met. As per inheritance, if the lower values are greater/smaller we know upwards it will also match.|[Code CPP](problems/leetcode/98.cpp)|[Code Python](problems/leetcode/98.py)|[LC_URL](https://leetcode.com/problems/validate-binary-search-tree)|
|128|Create a set for the numbers, then iterate through the set and for each number we check, if the next, and the next to next and so on number is in the set, only if the previous number is not in the set though. We keep count of the max sequence.|[Code CPP](problems/leetcode/128.cpp)|[Code Python](problems/leetcode/128.py)|[LC_URL](https://leetcode.com/problems/longest-consecutive-sequence)|
|143|Three steps: 1. Find the middle using slow and fast pointer. 2. Reverse the second part of the list. 3. Merge the lists.|[Code CPP](problems/leetcode/143.cpp)|[Code Python](problems/leetcode/143.py)|[LC_URL](https://leetcode.com/problems/reorder-list)|
|146|Use an ordered dict and keep track on the capacity of the cache when adding an item.|[Code CPP](problems/leetcode/146.cpp)|[Code Python](problems/leetcode/146.py)|[LC_URL](https://leetcode.com/problems/lru-cache)|
|150|Use stack for numbers, if we find a operator we handle the last two numbers on the stack and later push the result again to the stack.|[Code CPP](problems/leetcode/150.cpp)|[Code Python](problems/leetcode/150.py)|[LC_URL](https://leetcode.com/problems/evaluate-reverse-polish-notation)|
|153|Binary search, always compare the current value with the most left or right value to see in which portion of the array we are, change the pointers accordingly to find the lowest value.|[Code CPP](problems/leetcode/153.cpp)|[Code Python](problems/leetcode/153.py)|[LC_URL](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array)|
|155|Two stacks, one for the actual stack and one for the minimum value. Each entry check if we have to push to the minstack.|[Code CPP](problems/leetcode/155.cpp)|[Code Python](problems/leetcode/155.py)|[LC_URL](https://leetcode.com/problems/min-stack)|
|167|Two pointers, works as its sorted, and decrease right pointer if number is too big, increase left pointer if too small. If goal is found return left and right pointer values.|[Code CPP](problems/leetcode/167.cpp)|[Code Python](problems/leetcode/167.py)|[LC_URL](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)|
|230|Use a stack, first go down left lane and then check if already k or more elements are in the list, if no then go slowly right side down until more than k elements.|[Code CPP](problems/leetcode/230.cpp)|[Code Python](problems/leetcode/230.py)|[LC_URL](https://leetcode.com/problems/kth-smallest-element-in-a-bst)|
|235|Check for each node if p and q are both smaller/bigger. If one is the case go that direction of the tree, else return the current node.|[Code CPP](problems/leetcode/235.cpp)|[Code Python](problems/leetcode/235.py)|[LC_URL](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree)|
|238|Iterate through the list from both sides, keeping count from beginning and ending. Create new vector/array with these values.|[Code CPP](problems/leetcode/238.cpp)|[Code Python](problems/leetcode/238.py)|[LC_URL](https://leetcode.com/problems/product-of-array-except-self)|
|287|See the array as a linked list and the value of numbers act as a pointer to the index of the array. The duplicate number will always create a cycle, so we have to check if a cycle exists.|[Code CPP](problems/leetcode/287.cpp)|[Code Python](problems/leetcode/287.py)|[LC_URL](https://leetcode.com/problems/find-the-duplicate-number)|
|347|Prio Queue with pair of {number, count}. Build the heap and keep K elements in it. In the end iterate through the heap and output the resulting numbers.|[Code CPP](problems/leetcode/347.cpp)|[Code Python](problems/leetcode/347.py)|[LC_URL](https://leetcode.com/problems/top-k-frequent-elements)|
|424|Sliding window(l,r pointer), try for each window if replacement amount < max replacement allowed, update the result with longest.|[Code CPP](problems/leetcode/424.cpp)|[Code Python](problems/leetcode/424.py)|[LC_URL](https://leetcode.com/problems/longest-repeating-character-replacement/)|
|567|Sliding Window, use Map for tracking the counts. Slide Window over s2 and reduce counts if we find a matching value. In the end, if the count of the not matched s1 values is 0 we know we found the anagram.|[Code CPP](problems/leetcode/567.cpp)|[Code Python](problems/leetcode/567.py)|[LC_URL](https://leetcode.com/problems/permutation-in-string/)|
|739|Iterate the input from the back, use a stack to keep the indices of the temperatures that have a smaller value. Every iteration we iterate and count the number of temperatures lower than the current, so we find out how long until finding a bigger one. Output the result array in the end.|[Code CPP](problems/leetcode/739.cpp)|[Code Python](problems/leetcode/739.py)|[LC_URL](https://leetcode.com/problems/daily-temperatures)|
|853|Sort the cars on the strarting point, use stack to keep track of most recent rounds to finish. If the current car would catch up to the car on the stack, as in the rounds are greater than the rounds on the stack, don't create a new fleet, otherwise create a new fleet. Return the number of fleets in the end.|[Code CPP](problems/leetcode/853.cpp)|[Code Python](problems/leetcode/853.py)|[LC_URL](https://leetcode.com/problems/car-fleet/)|
|875|Treat the eating speed per hour as a list with upper bound (the max pile value) and lower bound. Binary search through this while calulating the total time needed to eat all bananas for each value.|[Code CPP](problems/leetcode/875.cpp)|[Code Python](problems/leetcode/875.py)|[LC_URL](https://leetcode.com/problems/koko-eating-bananas)|
|981|Set -> use a list of value,timestamp for each of the keys. Get -> binary search over the timestamp values.|[Code CPP](problems/leetcode/981.cpp)|[Code Python](problems/leetcode/981.py)|[LC_URL](https://leetcode.com/problems/time-based-key-value-store)|
|1448|For each node calculate the current greatest above value, then dfs down left and right side and return amount of good nodes up.|[Code CPP](problems/leetcode/1448.cpp)|[Code Python](problems/leetcode/1448.py)|[LC_URL](https://leetcode.com/problems/count-good-nodes-in-binary-tree)|
|**HARD**|**HARD**|**HARD**|**HARD**|**HARD**|
|4|Get middle of both arrays, then binary search the smaller one with left/mid/right, and compare with the middle of the long array. Shift left/right/middle accordingly until we have the right points in the long and short array that are the actual middle of the combined array.|[Code CPP](problems/leetcode/4.cpp)|[Code Python](problems/leetcode/4.py)|[LC_URL](https://leetcode.com/problems/median-of-two-sorted-arrays)|
|42|Left and right pointer as well as a maximum value of left and right, the for each step of the way we calculate the water trapped in that step. Return the volume of the water in the end.|[Code CPP](problems/leetcode/42.cpp)|[Code Python](problems/leetcode/42.py)|[LC_URL](https://leetcode.com/problems/trapping-rain-water)|
|76|Map for the letters we have to find. Two pointers to check for each index until all the needed chars are found. In the end, check the lowest length. Output that number.|[Code CPP](problems/leetcode/76.cpp)|[Code Python](problems/leetcode/76.py)|[LC_URL](https://leetcode.com/problems/minimum-window-substring)|
|84|Go through heights and use a stack to keep the latest indexes and heights. As long as current height is smaller than latest stack height, pop from stack and calculate max area. Remember to clear stack in the end by calculating the max area for remaining heights. Return max area.|[Code CPP](problems/leetcode/84.cpp)|[Code Python](problems/leetcode/84.py)|[LC_URL](https://leetcode.com/problems/largest-rectangle-in-histogram)|
|239|Use a vector for the result, deque for the checking. For each step, remove the numbers that are smaller than the current one. Remove also the number that is i-k so that we remove the one that is not in the window. Output the result of the highest numbers, the front of the deque, for each window.|[Code CPP](problems/leetcode/239.cpp)|[Code Python](problems/leetcode/239.py)|[LC_URL](https://leetcode.com/problems/sliding-window-maximum)|
|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|**EXAMPLE**|
|X|Explanation.|[Code CPP](problems/leetcode/XA.cpp)|[Code Python](problems/leetcode/XA.py)|[LC_URL](URL)|